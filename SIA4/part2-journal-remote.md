
### Возможности сетевого транспорта логов

Наверняка многие считают, что journald, в отличие от многих реализаций syslogd,
не умеет передавать логи по сети и ограничен исключительно локальной их обработкой.
Однако, это не совсем так. Сам по себе `systemd-journald`, действительно, ничего
не знает про сеть и пишет либо в syslog-совместимый сокет, либо в файлы нативного
формата. Тем не менее, в комплекте поставки systemd существуют три вспомогательные
утилиты, с помощью которых и реализуется передача логов по сети в реальном времени
"своими силами".

*Важное замечание: эти утилиты работают исключительно с логфайлами на диске (т. е.
в нулевом приближении они похожи на `tail -f | netcat`). Поэтому для того, чтобы
передавать логи по сети средствами journald, необходимо включить запись файлов в
нативном формате --- хотя бы в режиме `Storage=volatile`.*

Итак, в systemd/journald существуют два способа передачи логов через сеть:

* достаточно необычная **pull-модель**, при которой лог-сервер инициирует соединение
  и запрашивает данные, в то время как на самом деле сервер ([`systemd-journal-gatewayd`][10])
  работает на источнике;

* и более традиционная **push-модель**, когда лог-сервер в действительности является
  сервером, а открывает соединение и отправляет данные машина-источник
  (а именно утилита [`systemd-journal-upload`][11]).

На лог-сервере же в обоих случаях запускается [`systemd-journal-remote`][12].

Опять же, в обоих случаях данные передаются по сети поверх протокола HTTP(S) в
подробном [почти текстовом формате][13] вида `KEY=VALUE`. Данные именно в этом
формате возвращаются командой `journalctl -o export`.

#### Способ первый --- "pull"

В этом режиме на источнике логов мы запускаем самый настоящий специализированный
HTTP-сервер [`systemd-journal-gatewayd`][10] (реализованный с помощью libmicrohttpd).

Вообще, у этого сервера нет даже конфигурационного файла: всё достигается прямым
редактированием юнитов. Так, например, он представляет собой обычный сокет-активируемый
сервис, поэтому чтобы изменить порт, на котором он будет принимать соединения,
следует обратиться к юниту `systemd-journal-gatewayd.socket` и изменить в нём
значение директивы [`ListenStream=`][14]. Или, например, для того, чтобы задать
сертификат и секретный ключ HTTPS, достаточно изменить юнит `systemd-journal-gatewayd.service`,
дописав в командную строку демона параметры `--cert=` и `--key=`.

Нас вполне устраивает стандартный порт 19531 (а настройку HTTPS для краткости мы опустим),
поэтому сразу перейдём к запуску этого сервера на отдельной машине:

```
# systemctl start systemd-journal-gatewayd.socket
```

HTTP API этого сервера достаточно прост (и описан в документации). В частности:

---------------------------------------------------------------------------------------------------
Адрес              Ответ сервера
------------------ --------------------------------------------------------------------------------
`/browse`          интерактивная веб-консоль

`/entries`         *(основной метод)* дамп журнала

`/machine`         JSON-структура, описывающая систему (machine-id, boot-id, ...)

`/fields/<field>`  список всех значений, которые принимает поле `<field>` на данном участке журнала
---------------------------------------------------------------------------------------------------

[10]: http://www.freedesktop.org/software/systemd/man/systemd-journal-gatewayd.service.html
[11]: http://www.freedesktop.org/software/systemd/man/systemd-journal-upload.html
[12]: http://www.freedesktop.org/software/systemd/man/systemd-journal-remote.html
[13]: https://wiki.freedesktop.org/www/Software/systemd/export/
[14]: http://www.freedesktop.org/software/systemd/man/systemd.socket.html#ListenStream=